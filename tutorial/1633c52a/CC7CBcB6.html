<!-- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd"> -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
 	<meta name="description" content="编程">
 	<meta name="keywords" content="IT教程 ">
    <meta name="viewport" content="width=device-width, initial-scale=1 , user-scalable=no">
    
<!-- <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/> -->
<title>最短路径-Dijkstra-计算机算法基础</title>


    

	<link rel="stylesheet" href="/lib/css/bootstrap.min.css">
    <link rel="stylesheet" href="/lib/css/bootstrap-maizi.css">
    <link rel="stylesheet" href="/lib/css/animate.css">
    <!-- <script  src="https://libs.baidu.com/jquery/1.10.2/jquery.min.js"></script> -->
    <script src="/lib/js/jquery.min.js"></script>
    <script src="/lib/js/bootstrap.min.js"></script>
    
    <script src="/lib/js/jquery.singlePageNav.min.js"></script>
    <script src="/lib/js/jquery.cookie.js"></script>
    
	
<script src="/js/article.js"></script>
<!--百度统计-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a684a10bc59d54f03381c502765556bb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script type="text/javascript">
    // var siteHome = './';
    var staticHTMLUri = '/';
</script>


</head>
<body>
	
		  
		   <div style="height:50px;margin-bottom: 0px;"><nav class="navbar navbar-default navbar-fixed-top" id="topNav">		   <div class="container"> 
		    <!--导航--> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-header"> 
		     <button class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> 
		     <a href="http://qtxjc.com" class="navbar-brand" style="color: #1196EE;"><span>趣通小教程</span>&nbsp;<span>qtxjc.com</span></a> 
		    </div> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-collapse collapse"> 
		     <div class="profile navbar-right"> 
			      <!-- 	<ul class="nav navbar-nav"> 
			       		<li><a href="#home" data-toggle="modal" id="collector">收藏夹</a></li>
			       		<li><a href="#home" data-toggle="modal" id="homePageloginBtn">登录</a></li> 
			      		<li><a href="#home" data-toggle="modal" id="loginStatus"></a></li> 
			      	</ul>  -->
		      		
		     </div> 
		     <ul class="nav navbar-nav navbar-center"> 
		      <li> 
		       <!--搜索框--> 
		       <div class="input-group hidden" id="searchBox" style="max-width:300px;height:30px;margin-top:10px;"> 
		        <input type="text" class="form-control input-md" placeholder="输入关键词" onkeydown="onKeyDown(event)" /> 
		        <span class="input-group-addon btn btn-primary">搜索</span> 
		       </div> 
		       <!--搜索框--></li> 
	
		     </ul> 
		    </div> 
		   </div> </nav></div>
		  
	
	
<style type="text/css">
    .panel-heading{
        padding-top: 5px;
        padding-right: 5px;
    }
    .panel-body {
        padding: 10px;
    }
    .panel-body div {
        padding-left: 20px;
    }

    .menu-container{
        border-width: 2px;
        border-radius: 5px;
        border-color: green;
        border:5px solid #f6f4f0;
    
    }
    .menu-container div{
        padding-right: 10px;
        padding-left: 10px;
        line-height: 30px;
    }
    .chapter{
        background-color: #f0f0f0;
        font-weight: bold;

    }
    .course{
        background-color: #e2e2e2;
        text-indent: 0em;
    }
    .normal{
        color: black;
    }
    .selected{
        background-color: #1196EE;
        color: white;
    }
    .block{
        /*border: thick solid #e1e1e1;*/
        
    }
    .preview{
        display: none;
    }
    .item{
        border-bottom-style:solid;
        border-width: 1px;
        border-color: #f1f1f1;
        cursor:pointer;
    }
    .content{
        border-radius: 5px;
    }
    a:hover{
        text-decoration: none;
    }
    body{
        background-color: #dfdfdf;
    }
    td {
        border: 1px solid #ddd
    }
</style>
<div class="container">
<!-- <div class="row">
    <div class="col-sm-12" style="background-color: white;border-radius:8px;border-style: solid;border-color:#dfdfdf ">
        
    </div>
</div> -->
<div class="row">
    <div class="col-sm-12 text-center" style="padding-top: 20px;">
        <strong>最短路径-Dijkstra-计算机算法基础</strong>
    </div>
</div>
<div class="row" style="margin-top:5px;">
    <div class="col-sm-2" style="overflow-y: auto;max-height:100%;overflow-x: hidden;">
                <div class="menu-container">
                    <div id="ba1a7385" class="item chapter normal selected">查找</div><div id="bC91cAA3" class="item course normal">顺序表的查找</div><div id="59C30C90" class="item course normal">链表的查找</div><div id="b2A8C43b" class="item course normal">哈希表查找</div><div id="1B446667" class="item course normal">二叉树查找</div><div id="7186a499" class="item chapter normal">图</div><div id="89242a37" class="item course normal">邻接矩阵存储</div><div id="aB06c8b5" class="item course normal">邻接表(无向)</div><div id="23747CCA" class="item course normal">邻接表(有向)</div><div id="2B53B4Bc" class="item course normal">十字链表(有向图)</div><div id="A75B8C5A" class="item course normal">无向多重表</div><div id="79918209" class="item course normal">最小生成树(MST)</div><div id="724518A8" class="item course normal">MST性质</div><div id="68607210" class="item course normal">MST-Prim算法</div><div id="c5Ba3bB6" class="item course normal">MST-Kruskal算法</div><div id="CC7CBcB6" class="item course normal">最短路径-Dijkstra</div><div id="1aB39452" class="item course normal">最短路径-Floyd</div><div id="cb6A7026" class="item course normal">拓扑排序</div><div id="B37a3Aac" class="item course normal">关键路径-AOE网</div><div id="26516c04" class="item course normal">A星寻路算法</div><div id="B7583489" class="item chapter normal">字符串匹配</div><div id="0a54A6aa" class="item course normal">BF算法</div><div id="66ba80A3" class="item course normal">KMP算法</div><div id="AB7bABBa" class="item course normal">BM算法</div><div id="c738Cc8A" class="item course normal">Sunday算法</div><div id="C637c842" class="item chapter normal">排序</div><div id="10Cc3938" class="item course normal">插入排序</div><div id="BaCbB45A" class="item course normal">希尔排序</div><div id="b6001cca" class="item course normal">冒泡排序</div><div id="b6bC0C9a" class="item course normal">快速排序</div><div id="B3c8B431" class="item course normal">选择排序</div><div id="A007c6c1" class="item course normal">堆排序</div><div id="130932B3" class="item course normal">归并排序</div><div id="1857C7A4" class="item course normal">计数排序</div><div id="a494106a" class="item course normal">基数排序</div><div id="C7b5AcBB" class="item course normal">二叉树排序</div><div id="B8CBb284" class="item course normal">AVL树</div><div id="4124Bc76" class="item course normal">B树</div><div id="8CB3C5B5" class="item course normal">B+树</div><div id="b1926855" class="item course normal">红黑树</div><div id="2137C76A" class="item chapter normal">动态规划</div><div id="ac1c04B0" class="item course normal">最长公共子序列</div><div id="4c592cB8" class="item course normal">最优二叉搜索树</div><div id="b95C7914" class="item chapter normal">fft算法</div><div id="542c658b" class="item chapter normal">最长回文子字符串</div><div id="398a5C44" class="item chapter normal">算法思想分类</div><div id="1aC31776" class="item chapter normal">其它资料</div>
                </div>
                <div style="float:left;margin-top: 30px;width: 1px;height: 100%;background: darkgray;"></div>
        </div>
    <div class="col-sm-10 content" style="overflow-y: auto;height: 100%;background-color: white;padding-top:20px;">
         <div class="row">
             <div class="col-sm-12">
                 <p style="margin: 10px auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);">Dijkstra算法又称为单源最短路径，所谓单源是在一个有向图中，从一个顶点出发，求该顶点至所有可到达顶点的最短路径问题。&nbsp;<br style="margin: 0px; padding: 0px;"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设G=（V，E）是一个有向图，V表示顶点，E表示边。它的每一条边（i，j）属于E，都有一个非负权W（I,j），在G中指定一个结点v0，要求把从v0到G的每一个接vj（vj属于V）的最短有向路径找出来（或者指出不存在）。<br style="margin: 0px; padding: 0px;"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dijstra算法是运用贪心的策略，从源点开始，不断地通过相联通的点找出到其他点的最短距离<br style="margin: 0px; padding: 0px;"/>基本思想是：<br style="margin: 0px; padding: 0px;"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置一个顶点的集合s，并不断地扩充这个集合，一个顶点属于集合s当且仅当从源点到该点的路径已求出。开始时s中仅有源点，并且调整非s中点的最短路径长度，找当前最短路径点，将其加入到集合s，直到终点在s中。<br style="margin: 0px; padding: 0px;"/>基本步骤：<br style="margin: 0px; padding: 0px;"/>1、把所有结点分成两组：<br style="margin: 0px; padding: 0px;"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一组：包括已经确定最短路径的结点；<br style="margin: 0px; padding: 0px;"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二组：包括尚未确定最短路径的结点。<br style="margin: 0px; padding: 0px;"/>2、开始时，第一组只包含起点，第二组包含剩余的点；<br style="margin: 0px; padding: 0px;"/>3、用贪心的策略，按最短路径长度递增的顺序把第二组的结点加到第一组去，直到v0可达的所有结点都包含于第一组中。在这个过程中，不断更新最短路径，总保持从v0到第一组各结点的最短路径长度dist都不大于从v0到第二组任何结点的路径长度。<br style="margin: 0px; padding: 0px;"/>4、每个结点对应一个距离值，第一组结点对应的距离就是v0到此结点的最短路径长度，第二组结点对应的距离值就是v0由第一组结点到此结点的最短路径长度。<br style="margin: 0px; padding: 0px;"/>5、直到所有的顶点都扫描完毕（v0可达的所有结点都包含于第一组中），找到v0到其它各点的所有最短路径。</p><p style="margin: 10px auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="margin: 10px auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;如图：求0点到其他点的最短路径。</p><p style="margin: 10px auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);"><img src="/upload/image/20191115/100849597784.png" alt="" border="0" style="margin: 0px; padding: 0px; border: 0px; max-width: 900px; height: auto;"/><img src="/upload/image/20191115/100850134384.png" alt="" width="514" height="139" border="0" style="margin: 0px; padding: 0px; border: 0px; max-width: 900px; height: auto;"/></p><p style="margin: 10px auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.3333px; white-space: normal; background-color: rgb(255, 255, 255);">(1)开始时，s1={v0},s2={v1,v2,v3,v4}，v0到各点的最短路径是{0,10,&amp;,30,100};<br style="margin: 0px; padding: 0px;"/>(2)在还未进入s1的顶点之中，最短路径为v1，因此s1={v0,v1},由于v1到v2有路径，因此v0到各点的最短路径更新为{0,10,60,30,100};<br style="margin: 0px; padding: 0px;"/>(3)在还未进入s1的顶点之中，最短路径为v3，因此s1={v0,v1,v3},由于v3到v2、v4有路径，因此v0到各点的最短路径更新为{0,10,50,30,90}；<br style="margin: 0px; padding: 0px;"/>(4)在还未进入s1的顶点之中，最短路径为v2，因此s1={v0,v1,v3,v2},由于v2到v4有路径，因此v0到各点的最短路径更新为{0,10,50,30,60};<br style="margin: 0px; padding: 0px;"/>数据结构：<br style="margin: 0px; padding: 0px;"/>(1)用一个二维数组a[i..j,i..j]来存储各点之间的距离，10000表示无通路：<br style="margin: 0px; padding: 0px;"/>(2)用数组dist[i..j]表示最短路径；<br style="margin: 0px; padding: 0px;"/>(3)用集合s表示找到最短路径的结点。&nbsp;</p><p>http://ghj19850926.blog.163.com/blog/static/185915602014112351326191/</p><p>&nbsp;</p><p style="margin: 10px auto; padding: 0px;"><strong style="margin: 0px; padding: 0px;">&nbsp;Dijkstra算法解决了有向图上带正权值的单源最短路径问题，其运行时间要比Bellman-Ford算法低，但适用范围比Bellman-Ford算法窄。</strong></p><p style="margin: 10px auto; padding: 0px;">迪杰斯特拉提出的按路径长度递增次序来产生源点到各顶点的最短路径的<strong style="margin: 0px; padding: 0px;">算法思想是</strong>：对有n个顶点的有向连通网络G=(V, E)，首先从V中取出源点u0放入最短路径顶点集合U中，这时的最短路径网络S=({u0}, {?}); 然后从u?U和v?V－U中找一条代价最小的边(u*, v*)加入到S中去，此时S=({u0, v*}, {(u0, v*)})。每往U中增加一个顶点，则要对V－U中的各顶点的权值进行一次修正。若加进v*作为中间顶点，使得从u0到其他属于V－U的顶点vi的路径不加v*时最短，则修改u0到vi的权值，即以(u0, v*)的权值加上(v*, vi )的权值来代替原(u0, vi )的权值，否则不修改u0到vi的权值。接着再从权值修正后的V－U中选择最短的边加入S中，如此反复，直到U=V为止。</p><p style="margin: 10px auto; padding: 0px;">上面的说明都很抽象，<strong style="margin: 0px; padding: 0px;">下面图解算法思想：</strong></p><p style="margin: 10px auto; padding: 0px;">&nbsp; &nbsp; &nbsp;<strong style="margin: 0px; padding: 0px;">&nbsp;原始图为：</strong></p><p style="margin: 10px auto; padding: 0px;">&nbsp; &nbsp; &nbsp;<img src="/upload/image/20191115/100854828320.png" alt="" style="margin: 0px; padding: 0px; border: 0px; max-width: 900px; height: auto;"/></p><p style="margin: 10px auto; padding: 0px;"><strong style="margin: 0px; padding: 0px;">寻找最短路径的过程如下：</strong></p><p style="margin: 10px auto; padding: 0px;"><img src="/upload/image/20191115/100856856789.png" alt="" style="margin: 0px; padding: 0px; border: 0px; max-width: 900px; height: auto;"/></p><p style="margin: 10px auto; padding: 0px;">&nbsp; &nbsp; &nbsp; &nbsp; 对第一个图中的有向网络按以上算法思想处理，所求得的从源点F到其余顶点的最短路径的过程如图13.16所示。其中单圆圈表示U中的顶点，而双圆圈表示V－U中的顶点。连接U中两个顶点的有向边用实线表示，连接U和V－U中两个顶点的有向边用虚线表示。圆圈旁的数字为源点到该顶点当前的距离值。<br style="margin: 0px; padding: 0px;"/>&nbsp; &nbsp; &nbsp; &nbsp; 初始时，S中只有一个源点F，它到V－U中各顶点的路径如图13.16(a)所示；选择图13.16(a)中最小代价边(F, B)，同时由于路径(F, A)大于(F, B, A)和(F, C)大于(F, B, C)，进行相应调整可得到图13.16(b)；选择图13.16(b)中的最小代价边(B, C)，同时由于(F, B, A)大于(F, B, C, A)，进行相应调整可得到图13.16(c)；选择图13.16(c)中最小代价边(C, A)即可得到图13.16(d)；选择图13.16(d)中最小代价边(F, D) 即可得到图13.16(e); 最后选择(F, E)即可得到图13.16( f )。</p><p style="margin: 10px auto; padding: 0px;"><a href="https://www.cnblogs.com/virusolf/p/4410267.html" target="_blank">原文链接</a>:<a href="https://www.cnblogs.com/virusolf/p/4410267.html">https://www.cnblogs.com/virusolf/p/4410267.html</a></p><p><iframe src="//player.bilibili.com/player.html?aid=36886088&cid=64786577&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="600px"> </iframe></p>
             </div>
         </div>
        <div class="row" style="background-color: #eeeeee;">
            
             <div class="col-sm-4 text-left left-arror">
                 
             </div>
       
             <div class="col-sm-4 col-sm-offset-4 text-right right-arror">
                
             </div>
        
         </div>

    </div>
</div>
<div class="row">
    <div class="col-sm-12 text-center" style="padding-top: 10px;">
        <a href="https://www.onlinegdb.com/" target="_blank"><strong><font color="black">在线编程工具</font></strong></a>
    </div>
</div>
</div>
<script type="text/javascript">
// var siteHome = './';
var tutorial_id = '1633c52a';
var article_id = 'CC7CBcB6';
</script>

	
	<a href="https://beian.miit.gov.cn"><div style="text-align: center; height: 60px;padding-top: 20px;">鄂ICP备20003145号-1</div></a>	
	
</body>