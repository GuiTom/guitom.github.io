<!-- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd"> -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
 	<meta name="description" content="编程">
 	<meta name="keywords" content="IT教程 ">
    <meta name="viewport" content="width=device-width, initial-scale=1 , user-scalable=no">
    
<!-- <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/> -->
<title>UI显示原理-iOS开发(高级篇)</title>


    

	<link rel="stylesheet" href="/lib/css/bootstrap.min.css">
    <link rel="stylesheet" href="/lib/css/bootstrap-maizi.css">
    <link rel="stylesheet" href="/lib/css/animate.css">
    <!-- <script  src="https://libs.baidu.com/jquery/1.10.2/jquery.min.js"></script> -->
    <script src="/lib/js/jquery.min.js"></script>
    <script src="/lib/js/bootstrap.min.js"></script>
    
    <script src="/lib/js/jquery.singlePageNav.min.js"></script>
    <script src="/lib/js/jquery.cookie.js"></script>
    
	
<script src="/js/article.js"></script>
<!--百度统计-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a684a10bc59d54f03381c502765556bb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script type="text/javascript">
    // var siteHome = './';
    var staticHTMLUri = '/';
</script>


</head>
<body>
	
		  
		   <div style="height:50px;margin-bottom: 0px;"><nav class="navbar navbar-default navbar-fixed-top" id="topNav">		   <div class="container"> 
		    <!--导航--> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-header"> 
		     <button class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> 
		     <a href="http://qtxjc.com" class="navbar-brand" style="color: #1196EE;"><span>趣通小教程</span>&nbsp;<span>qtxjc.com</span></a> 
		    </div> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-collapse collapse"> 
		     <div class="profile navbar-right"> 
			      <!-- 	<ul class="nav navbar-nav"> 
			       		<li><a href="#home" data-toggle="modal" id="collector">收藏夹</a></li>
			       		<li><a href="#home" data-toggle="modal" id="homePageloginBtn">登录</a></li> 
			      		<li><a href="#home" data-toggle="modal" id="loginStatus"></a></li> 
			      	</ul>  -->
		      		
		     </div> 
		     <ul class="nav navbar-nav navbar-center"> 
		      <li> 
		       <!--搜索框--> 
		       <div class="input-group hidden" id="searchBox" style="max-width:300px;height:30px;margin-top:10px;"> 
		        <input type="text" class="form-control input-md" placeholder="输入关键词" onkeydown="onKeyDown(event)" /> 
		        <span class="input-group-addon btn btn-primary">搜索</span> 
		       </div> 
		       <!--搜索框--></li> 
	
		     </ul> 
		    </div> 
		   </div> </nav></div>
		  
	
	
<style type="text/css">
    .panel-heading{
        padding-top: 5px;
        padding-right: 5px;
    }
    .panel-body {
        padding: 10px;
    }
    .panel-body div {
        padding-left: 20px;
    }

    .menu-container{
        border-width: 2px;
        border-radius: 5px;
        border-color: green;
        border:5px solid #f6f4f0;
    
    }
    .menu-container div{
        padding-right: 10px;
        padding-left: 10px;
        line-height: 30px;
    }
    .chapter{
        background-color: #f0f0f0;
        font-weight: bold;

    }
    .course{
        background-color: #e2e2e2;
        text-indent: 0em;
    }
    .normal{
        color: black;
    }
    .selected{
        background-color: #1196EE;
        color: white;
    }
    .block{
        /*border: thick solid #e1e1e1;*/
        
    }
    .preview{
        display: none;
    }
    .item{
        border-bottom-style:solid;
        border-width: 1px;
        border-color: #f1f1f1;
        cursor:pointer;
    }
    .content{
        border-radius: 5px;
    }
    a:hover{
        text-decoration: none;
    }
    body{
        background-color: #dfdfdf;
    }
    td {
        border: 1px solid #ddd
    }
</style>
<div class="container">
<!-- <div class="row">
    <div class="col-sm-12" style="background-color: white;border-radius:8px;border-style: solid;border-color:#dfdfdf ">
        
    </div>
</div> -->
<div class="row">
    <div class="col-sm-12 text-center" style="padding-top: 20px;">
        <strong>UI显示原理-iOS开发(高级篇)</strong>
    </div>
</div>
<div class="row" style="margin-top:5px;">
    <div class="col-sm-2" style="overflow-y: auto;max-height:100%;overflow-x: hidden;">
                <div class="menu-container">
                    <div id="06024caB" class="item chapter normal selected">Runtime</div>

<div id="5b514C5a" class="item course normal">方法交换</div>
<div id="67C92673" class="item course normal">动态添加方法</div>
<div id="8A546ac3" class="item course normal">关联对象</div><div id="39c93aA5" class="item course normal">KVO的实现</div><div id="93C8046a" class="item chapter normal">内存管理</div><div id="c1944c7C" class="item course normal">TaggedPointer</div><div id="3ABca2ab" class="item course normal">小测验</div><div id="AAB71A4b" class="item course normal">NONPOINTER_ISA</div><div id="3Ac50559" class="item course normal">散列表 </div><div id="8BA7CC22" class="item course normal">Copy和mutableCopy</div><div id="6B5C7c25" class="item course normal">对象的销毁dealloc</div><div id="97cc9C51" class="item course normal">常用lldb命令</div>


































<div id="9ccab66A" class="item chapter normal">RunLoop</div><div id="3C6a652B" class="item course normal">NSTimer应用</div><div id="07A53392" class="item course normal">线程保活</div><div id="4a6ac2bb" class="item course normal">UIImage空闲时渲染</div><div id="A5bCb944" class="item course normal">线程间通信(NSPort)</div><div id="471ab021" class="item course normal">卡顿检测</div><div id="30A6AA7A" class="item course normal">自动释放池</div><div id="2A662A6A" class="item chapter normal">UI视图</div><div id="4b1Aa8ba" class="item course normal">UI绘制原理</div><div id="C1AB418B" class="item course normal">UI事件传递机制</div><div id="3C991812" class="item course normal">事件传递相关练习题</div><div id="12B75430" class="item course normal">事件响应链</div><div id="4Cc0CC83" class="item course normal">相关面试题</div><div id="0CbB19c9" class="item chapter normal">多线程</div><div id="217b960B" class="item course normal">pthread</div><div id="53870C1a" class="item course normal">NSThread</div><div id="3a61B9a4" class="item course normal">GCD基础API(1)</div><div id="88bB0879" class="item course normal">GCD基础API(2)</div><div id="cc300B3b" class="item course normal">GCD经典面试题</div><div id="29108B1C" class="item course normal">GCD高级 API</div><div id="8BC7b1B3" class="item course normal">NSOpreation</div><div id="4635Bb8A" class="item course normal">多线程面试题</div><div id="C5C1C965" class="item course normal">锁</div><div id="28c98C11" class="item course normal">锁相关面试题</div><div id="B529829C" class="item course normal">信号量</div><div id="8a900c58" class="item chapter normal">OC语言</div><div id="A01181B1" class="item course normal">属性关键字</div><div id="a24C78b3" class="item course normal">内存管理</div><div id="1472b4c0" class="item course normal">KVO</div><div id="BC924416" class="item chapter normal">block及其本质</div><div id="61a4a56A" class="item course normal">block按存储区分类</div><div id="C3803054" class="item course normal">变量截取</div><div id="Cc14A93c" class="item course normal">相关面试题</div><div id="a6a97753" class="item chapter normal">第三方库</div><div id="14ab67AB" class="item course normal">AFNetWorking</div><div id="6A235a3B" class="item course normal">SDWebImageView</div><div id="2c7C0120" class="item course normal">ReactiveCocoa</div><div id="a5488b6B" class="item course normal">AsyncDisplayKit</div><div id="B5b3B053" class="item chapter normal">性能优化</div><div id="0A415471" class="item course normal">UI卡顿优化</div><div id="C094BcBc" class="item course normal">离屏渲染优化</div><div id="b2b21885" class="item course normal">卡顿检测</div><div id="56529C54" class="item course normal">电量优化</div><div id="AcaAbB32" class="item course normal">APP冷启动优化</div>
                </div>
                <div style="float:left;margin-top: 30px;width: 1px;height: 100%;background: darkgray;"></div>
        </div>
    <div class="col-sm-10 content" style="overflow-y: auto;height: 100%;background-color: white;padding-top:20px;">
         <div class="row">
             <div class="col-sm-12">
                 <p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">这篇文章会非常详细的分析 iOS 界面构建中的各种性能问题以及对应的解决思路，同时给出一个开源的微博列表实现，通过实际的代码展示如何构建流畅的交互。</p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">Index<br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#1" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">演示项目</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#2" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">屏幕显示图像的原理</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#3" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">卡顿产生的原因和解决方案</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#31" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">CPU 资源消耗原因和解决方案</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#32" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">GPU 资源消耗原因和解决方案</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#4" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">AsyncDisplayKit</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#41" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">ASDK 的由来</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#42" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">ASDK 的资料</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#43" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">ASDK 的基本原理</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#44" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">ASDK 的图层预合成</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#45" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">ASDK 异步并发操作</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#46" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">Runloop 任务分发</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#5" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">微博 Demo 性能优化技巧</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#51" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">预排版</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#52" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">预渲染</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#53" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">异步绘制</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#54" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">全局并发控制</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#55" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">更高效的异步图片加载</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#56" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 30px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">其他可以改进的地方</a><br style="box-sizing: border-box;"/><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#6" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">如何评测界面的流畅度</a></p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(32, 154, 252);" name="1"></a></p><h2 class="none" style="box-sizing: border-box; margin: 30px 0px 0px; padding: 0px 0px 10px; border: 0px; outline: 0px; font-size: 26px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 1em; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;">演示项目</strong></h2><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">在开始技术讨论前，你可以先下载我写的 Demo 跑到真机上体验一下：<a href="https://github.com/ibireme/YYKit" target="_blank" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">https://github.com/ibireme/YYKit</a>。 Demo 里包含一个微博的 Feed 列表、发布视图，还包含一个 Twitter 的 Feed 列表。为了公平起见，所有界面和交互我都从官方应用原封不动的抄了过来，数据也都是从官方应用抓取的。你也可以自己抓取数据替换掉 Demo 中的数据，方便进行对比。尽管官方应用背后的功能更多更为复杂，但不至于会带来太大的交互性能差异。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/weibo.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41926" src="/upload/image/20191114/170633395035.png" alt="weibo" width="230" height="409" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/weibo_compose.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41927" src="/upload/image/20191114/170641362620.png" alt="weibo_compose" width="230" height="409" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/twitter.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41928" src="/upload/image/20191114/170644479944.png" alt="twitter" width="230" height="409" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">这个 Demo 最低可以运行在 iOS 6 上，所以你可以把它跑到老设备上体验一下。在我的测试中，即使在 iPhone 4S 或者 iPad 3 上，Demo 列表在快速滑动时仍然能保持 50~60 FPS 的流畅交互，而其他诸如微博、朋友圈等应用的列表视图在滑动时已经有很严重的卡顿了。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">微博的 Demo 有大约四千行代码，Twitter 的只有两千行左右代码，第三方库只用到了 YYKit，文件数量比较少，方便查看。好了，下面是正文。</p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><span id="more-41893" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"></span></p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(32, 154, 252);" name="2"></a></p><h2 class="none" style="box-sizing: border-box; margin: 30px 0px 0px; padding: 0px 0px 10px; border: 0px; outline: 0px; font-size: 26px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 1em; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;">屏幕显示图像的原理</strong></h2><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41896" src="/upload/image/20191114/170651152456.png" alt="ios_screen_scan" width="321" height="239" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41897" src="/upload/image/20191114/170652362863.png" alt="ios_screen_display" width="546" height="251" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41898" src="/upload/image/20191114/170653744097.png" alt="ios_vsync_off" width="500" height="294" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(32, 154, 252);" name="3"></a></p><h2 class="none" style="box-sizing: border-box; margin: 30px 0px 0px; padding: 0px 0px 10px; border: 0px; outline: 0px; font-size: 26px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 1em; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;">卡顿产生的原因和解决方案</strong></h2><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);"><img class="alignnone wp-image-41899" src="/upload/image/20191114/170655416710.png" alt="ios_frame_drop" width="712" height="184" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: bottom; background: transparent; max-width: 100%; height: auto;"/></a></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><a style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(32, 154, 252);" name="31"></a></p><h3 class="none" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 10px; border: 0px; outline: 0px; font-size: 22px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 1em; font-weight: 400; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;">CPU 资源消耗原因和解决方案</strong></h3><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">对象创建</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">对象调整</span></strong></p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时&nbsp;resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">对象销毁</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p><p style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><br/></p><pre class="brush:cpp;toolbar:false">NSArray&nbsp;*tmp&nbsp;=&nbsp;self.array;
self.array&nbsp;=&nbsp;nil;
dispatch_async(queue,&nbsp;^{
&nbsp;&nbsp;&nbsp;&nbsp;[tmp&nbsp;class];
});</pre><p style="box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &quot;Microsoft YaHei&quot;, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);"><span class="crayon-sy" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; font-family: inherit; height: inherit; font-size: inherit !important; line-height: inherit !important; font-weight: inherit !important;"></span><br/></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">&nbsp;布局计算</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">Autolayout</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">文本计算</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">文本渲染</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">图片的解码</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">&nbsp;图像的绘制</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p><p><span class="crayon-o" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-size: inherit !important; vertical-align: baseline; background: transparent; font-family: inherit; height: inherit; line-height: inherit !important; font-weight: inherit !important; color: rgb(0, 111, 224) !important;"></span></p><pre class="brush:cpp;toolbar:false">-&nbsp;(void)display&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(backgroundQueue,&nbsp;^{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CGContextRef&nbsp;ctx&nbsp;=&nbsp;CGBitmapContextCreate(...);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;draw&nbsp;in&nbsp;context...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CGImageRef&nbsp;img&nbsp;=&nbsp;CGBitmapContextCreateImage(ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CFRelease(ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(mainQueue,&nbsp;^{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layer.contents&nbsp;=&nbsp;img;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;});
}</pre><p><span class="crayon-sy" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-size: inherit !important; vertical-align: baseline; background: transparent; font-family: inherit; height: inherit; line-height: inherit !important; font-weight: inherit !important; color: rgb(51, 51, 51) !important;"></span><br/></p><p><textarea class="crayon-plain print-no" data-settings="" readonly="" style="box-sizing: border-box; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-width: 0px; border-style: initial; padding: 0px 5px; color: rgb(0, 0, 0); margin: 0px; width: 706.797px; overflow: hidden; height: 165px; position: absolute; opacity: 0; border-radius: 0px; box-shadow: none; overflow-wrap: normal; resize: none; tab-size: 4; z-index: 0; font-family: Consolas, ConsolasRegular, &quot;Courier New&quot;, monospace !important; font-size: 13px !important; line-height: 15px !important;"></textarea></p><h3 class="none" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 10px; border: 0px; outline: 0px; font-size: 22px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 1em; font-weight: 400; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;">&nbsp;GPU 资源消耗原因和解决方案</strong></h3><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">纹理的渲染</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：<a href="http://iosres.com/" target="_blank" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; text-decoration-line: none; color: rgb(32, 154, 252);">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">视图的混合 (Composing)</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent; color: rgb(141, 212, 0);">图形的生成。</span></strong></p><p class="none" style="box-sizing: border-box; margin-top: 0.9em; margin-bottom: 0.5em; padding: 0px 0px 0.6em; border: 0px; outline: 0px; vertical-align: baseline; background: rgb(255, 255, 255); color: rgb(29, 29, 29); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, Verdana, &quot;Hiragino Sans GB&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; white-space: normal;">CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#more-41893" target="_blank">原文链接</a>:<a href="https://blog.ibireme.com/#51"></a><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#more-41893">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#more-41893</a></p>
             </div>
         </div>
        <div class="row" style="background-color: #eeeeee;">
            
             <div class="col-sm-4 text-left left-arror">
                 
             </div>
       
             <div class="col-sm-4 col-sm-offset-4 text-right right-arror">
                
             </div>
        
         </div>

    </div>
</div>
<div class="row">
    <div class="col-sm-12 text-center" style="padding-top: 10px;">
        <a href="https://www.onlinegdb.com/" target="_blank"><strong><font color="black">在线编程工具</font></strong></a>
    </div>
</div>
</div>
<script type="text/javascript">
// var siteHome = './';
var tutorial_id = 'a948A25C';
var article_id = '7b80Cc94';
</script>

	
	<a href="https://beian.miit.gov.cn"><div style="text-align: center; height: 60px;padding-top: 20px;">鄂ICP备20003145号-1</div></a>	
	
</body>