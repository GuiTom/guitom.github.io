<!-- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd"> -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
 	<meta name="description" content="抖音数据分析服务">
 	<meta name="keywords" content="抖音排行榜,抖音数据,抖音营销-抖商助手 ">
    <meta name="viewport" content="width=device-width, initial-scale=1 , user-scalable=no">
    
<!-- <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/> -->
<title>H264-iOS音视频</title>


    

	<link rel="stylesheet" href="/lib/css/bootstrap.min.css">
    <link rel="stylesheet" href="/lib/css/bootstrap-maizi.css">
    <link rel="stylesheet" href="/lib/css/animate.css">
    <!-- <script  src="https://libs.baidu.com/jquery/1.10.2/jquery.min.js"></script> -->
    <script src="/lib/js/jquery.min.js"></script>
    <script src="/lib/js/bootstrap.min.js"></script>
    
    <script src="/lib/js/jquery.singlePageNav.min.js"></script>
    <script src="/lib/js/jquery.cookie.js"></script>
    
	
<script src="/js/article.js"></script>

<style type="text/css">

</style>
<script type="text/javascript">
    // var siteHome = './';
    var staticHTMLUri = '/';
</script>
</head>
<body>
	
		  
		   <div style="height:50px;margin-bottom: 0px;"><nav class="navbar navbar-default navbar-fixed-top" id="topNav">		   <div class="container"> 
		    <!--导航--> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-header"> 
		     <button class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> 
		     <a href="https://guitom.github.io/" class="navbar-brand" style="color: #1196EE;"><span>趣通小教程</span>&nbsp;<span>guitom.github.io</span></a> 
		    </div> 
		    <!--小屏幕导航按钮和logo--> 
		    <div class="navbar-collapse collapse"> 
		     <div class="profile navbar-right"> 
			      <!-- 	<ul class="nav navbar-nav"> 
			       		<li><a href="#home" data-toggle="modal" id="collector">收藏夹</a></li>
			       		<li><a href="#home" data-toggle="modal" id="homePageloginBtn">登录</a></li> 
			      		<li><a href="#home" data-toggle="modal" id="loginStatus"></a></li> 
			      	</ul>  -->
		      		
		     </div> 
		     <ul class="nav navbar-nav navbar-center"> 
		      <li> 
		       <!--搜索框--> 
		       <div class="input-group hidden" id="searchBox" style="max-width:300px;height:30px;margin-top:10px;"> 
		        <input type="text" class="form-control input-md" placeholder="输入关键词" onkeydown="onKeyDown(event)" /> 
		        <span class="input-group-addon btn btn-primary">搜索</span> 
		       </div> 
		       <!--搜索框--></li> 
	
		     </ul> 
		    </div> 
		   </div> </nav></div>
		  
	
	
<style type="text/css">
    .panel-heading{
        padding-top: 5px;
        padding-right: 5px;
    }
    .panel-body {
        padding: 10px;
    }
    .panel-body div {
        padding-left: 20px;
    }

    .menu-container{
        border-width: 2px;
        border-radius: 5px;
        border-color: green;
        border:5px solid #f6f4f0;
    
    }
    .menu-container div{
        padding-right: 10px;
        padding-left: 10px;
        line-height: 30px;
    }
    .chapter{
        background-color: #e2e2e2;
        font-weight: bold;
    }
    .course{
        background-color: #e2e2e2;
        text-indent: 1em;
    }
    .normal{
        color: black;
    }
    .selected{
        background-color: #1196EE;
        color: white;
    }
    .block{
        /*border: thick solid #e1e1e1;*/
        
    }
    .preview{
        display: none;
    }
    .item{
        border-bottom-style:solid;
        border-width: 1px;
        border-color: #f1f1f1;
        cursor:pointer;
    }
    a:hover{
        text-decoration: none;
    }
    body{
        background-color: #dfdfdf;
    }
    td {
        border: 1px solid #ddd
    }
</style>
<div class="container">
<!-- <div class="row">
    <div class="col-sm-12" style="background-color: white;border-radius:8px;border-style: solid;border-color:#dfdfdf ">
        
    </div>
</div> -->
<div class="row">
    <div class="col-sm-12 text-center">
        <strong>iOS音视频</strong>
    </div>
</div>
<div class="row" style="margin-top:5px;">
    <div class="col-sm-2" style="overflow-y: auto;max-height:100%;overflow-x: hidden;">
                <div class="menu-container">
                    <div id="3111b6c3" class="item chapter normal">iOS音视频开发概述</div><div id="32Ba8353" class="item course normal">音频概述</div><div id="1aa06ba5" class="item course normal">视频概述</div><div id="2208818C" class="item course normal selected">H264</div>
                </div>
                <div style="float:left;margin-top: 30px;width: 1px;height: 100%; background: darkgray;"></div>
        </div>
    <div class="col-sm-8" style="overflow-y: auto;height: 100%;background-color: white;">
         <h1 style="margin: 10px 0px; font-size: 14.7px; color: rgb(102, 102, 102); box-sizing: border-box;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/wainiwann/p/7477794.html" style="box-sizing: border-box; text-decoration-line: none; color: rgb(52, 104, 164);">H264码流中SPS PPS详解&lt;转&gt;</a></h1><ul style="list-style-type: none;" class=" list-paddingleft-2"><li><p>转载地址：https://zhuanlan.zhihu.com/p/27896239</p></li><li><p>1 SPS和PPS从何处而来？</p></li><li><p>2 SPS和PPS中的每个参数起什么作用？</p></li><li><p>3 如何解析SDP中包含的H.264的SPS和PPS串？</p></li></ul><p style="box-sizing: border-box; margin: 10px auto;">1 客户端抓包</p><p style="box-sizing: border-box; margin: 10px auto;">在做客户端视频解码时，一般都会使用Wireshark抓包工具对接收的H264码流进行分析，如下所示：</p><p style="text-align:center"><img src="/upload/image/20191022/195046474619.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">在这里我们可以看到对解码视频起关键作用的SPS和PPS。</p><p style="box-sizing: border-box; margin: 10px auto;">双击SPS内容如下：</p><p style="text-align:center"><img src="/upload/image/20191022/195046821371.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">双击PPS内容如下：</p><p style="text-align:center"><img src="/upload/image/20191022/195046627264.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">那么从上面的sps中我们知道图像的宽，高。</p><p style="box-sizing: border-box; margin: 10px auto;">宽=（19+1 ）*16=320</p><p style="box-sizing: border-box; margin: 10px auto;">高=（14+1）*16=240</p><p style="box-sizing: border-box; margin: 10px auto;">为什么？参考下面</p><p style="box-sizing: border-box; margin: 10px auto;">2 SPS PPS详解</p><p style="box-sizing: border-box; margin: 10px auto;">2.1 SPS语法元素及其含义</p><p style="box-sizing: border-box; margin: 10px auto;">在H.264标准协议中规定了多种不同的NAL Unit类型，其中类型7表示该NAL Unit内保存的数据为Sequence Paramater Set。在H.264的各种语法元素中，SPS中的信息至关重要。如果其中的数据丢失或出现错误，那么解码过程很可能会失败。SPS及后续将要讲述的图像参数集PPS在某些平台的视频处理框架（比如iOS的VideoToolBox等）还通常作为解码器实例的初始化信息使用。</p><p style="box-sizing: border-box; margin: 10px auto;">SPS即Sequence Paramater Set，又称作序列参数集。SPS中保存了一组编码视频序列(Coded video sequence)的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。一般情况SPS和PPS的NAL Unit通常位于整个码流的起始位置。但在某些特殊情况下，在码流中间也可能出现这两种结构，主要原因可能为：</p><ul style="list-style-type: none;" class=" list-paddingleft-2"><li><p>解码器需要在码流中间开始解码；</p></li><li><p>编码器在编码的过程中改变了码流的参数（如图像分辨率等）；</p></li></ul><p style="box-sizing: border-box; margin: 10px auto;">在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：</p><p style="text-align:center"><img src="/upload/image/20191022/195047227237.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">&nbsp;</p><p style="box-sizing: border-box; margin: 10px auto;">其中的每一个语法元素及其含义如下：</p><p style="box-sizing: border-box; margin: 10px auto;">(1) profile_idc：</p><p style="box-sizing: border-box; margin: 10px auto;">标识当前H.264码流的profile。我们知道，H.264中定义了三种常用的档次profile：</p><p style="box-sizing: border-box; margin: 10px auto;">基准档次：baseline profile;</p><p style="box-sizing: border-box; margin: 10px auto;">主要档次：main profile;</p><p style="box-sizing: border-box; margin: 10px auto;">扩展档次：extended profile;</p><p style="box-sizing: border-box; margin: 10px auto;">在H.264的SPS中，第一个字节表示profile_idc，根据profile_idc的值可以确定码流符合哪一种档次。判断规律为：</p><p style="box-sizing: border-box; margin: 10px auto;">profile_idc = 66 → baseline profile;</p><p style="box-sizing: border-box; margin: 10px auto;">profile_idc = 77 → main profile;</p><p style="box-sizing: border-box; margin: 10px auto;">profile_idc = 88 → extended profile;</p><p style="box-sizing: border-box; margin: 10px auto;">在新版的标准中，还包括了High、High 10、High 4:2:2、High 4:4:4、High 10 Intra、High 4:2:2 Intra、High 4:4:4 Intra、CAVLC 4:4:4 Intra等，每一种都由不同的profile_idc表示。</p><p style="box-sizing: border-box; margin: 10px auto;">另外，constraint_set0_flag ~ constraint_set5_flag是在编码的档次方面对码流增加的其他一些额外限制性条件。</p><p style="box-sizing: border-box; margin: 10px auto;">在我们实验码流中，profile_idc = 0x42 = 66，因此码流的档次为baseline profile。</p><p style="box-sizing: border-box; margin: 10px auto;">(2) level_idc</p><p style="box-sizing: border-box; margin: 10px auto;">标识当前码流的Level。编码的Level定义了某种条件下的最大视频分辨率、最大视频帧率等参数，码流所遵从的level由level_idc指定。</p><p style="box-sizing: border-box; margin: 10px auto;">当前码流中，level_idc = 0x1e = 30，因此码流的级别为3。</p><p style="box-sizing: border-box; margin: 10px auto;">(3) seq_parameter_set_id</p><p style="box-sizing: border-box; margin: 10px auto;">表示当前的序列参数集的id。通过该id值，图像参数集pps可以引用其代表的sps中的参数。</p><p style="box-sizing: border-box; margin: 10px auto;">(4) log2_max_frame_num_minus4</p><p style="box-sizing: border-box; margin: 10px auto;">用于计算MaxFrameNum的值。计算公式为MaxFrameNum = 2^(log2_max_frame_num_minus4 + 4)。MaxFrameNum是frame_num的上限值，frame_num是图像序号的一种表示方法，在帧间编码中常用作一种参考帧标记的手段。</p><p style="box-sizing: border-box; margin: 10px auto;">(5) pic_order_cnt_type</p><p style="box-sizing: border-box; margin: 10px auto;">表示解码picture order count(POC)的方法。POC是另一种计量图像序号的方式，与frame_num有着不同的计算方法。该语法元素的取值为0、1或2。</p><p style="box-sizing: border-box; margin: 10px auto;">(6) log2_max_pic_order_cnt_lsb_minus4</p><p style="box-sizing: border-box; margin: 10px auto;">用于计算MaxPicOrderCntLsb的值，该值表示POC的上限。计算方法为MaxPicOrderCntLsb = 2^(log2_max_pic_order_cnt_lsb_minus4 + 4)。</p><p style="box-sizing: border-box; margin: 10px auto;">(7) max_num_ref_frames</p><p style="box-sizing: border-box; margin: 10px auto;">用于表示参考帧的最大数目。</p><p style="box-sizing: border-box; margin: 10px auto;">(8) gaps_in_frame_num_value_allowed_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，说明frame_num中是否允许不连续的值。</p><p style="box-sizing: border-box; margin: 10px auto;">(9) pic_width_in_mbs_minus1</p><p style="box-sizing: border-box; margin: 10px auto;">用于计算图像的宽度。单位为宏块个数，因此图像的实际宽度为:</p><p style="box-sizing: border-box; margin: 10px auto;">frame_width = 16 × (pic\_width\_in\_mbs_minus1 + 1);</p><p style="box-sizing: border-box; margin: 10px auto;">(10) pic_height_in_map_units_minus1</p><p style="box-sizing: border-box; margin: 10px auto;">使用PicHeightInMapUnits来度量视频中一帧图像的高度。PicHeightInMapUnits并非图像明确的以像素或宏块为单位的高度，而需要考虑该宏块是帧编码或场编码。PicHeightInMapUnits的计算方式为：</p><p style="box-sizing: border-box; margin: 10px auto;">PicHeightInMapUnits = pic\_height\_in\_map\_units\_minus1 + 1;</p><p style="box-sizing: border-box; margin: 10px auto;">(11) frame_mbs_only_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，说明宏块的编码方式。当该标识位为0时，宏块可能为帧编码或场编码；该标识位为1时，所有宏块都采用帧编码。根据该标识位取值不同，PicHeightInMapUnits的含义也不同，为0时表示一场数据按宏块计算的高度，为1时表示一帧数据按宏块计算的高度。</p><p style="box-sizing: border-box; margin: 10px auto;">按照宏块计算的图像实际高度FrameHeightInMbs的计算方法为：</p><p style="box-sizing: border-box; margin: 10px auto;">FrameHeightInMbs = ( 2 − frame_mbs_only_flag ) * PicHeightInMapUnits</p><p style="box-sizing: border-box; margin: 10px auto;">(12) mb_adaptive_frame_field_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，说明是否采用了宏块级的帧场自适应编码。当该标识位为0时，不存在帧编码和场编码之间的切换；当标识位为1时，宏块可能在帧编码和场编码模式之间进行选择。</p><p style="box-sizing: border-box; margin: 10px auto;">(13) direct_8x8_inference_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，用于B_Skip、B_Direct模式运动矢量的推导计算。</p><p style="box-sizing: border-box; margin: 10px auto;">(14) frame_cropping_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，说明是否需要对输出的图像帧进行裁剪。</p><p style="box-sizing: border-box; margin: 10px auto;">(15) vui_parameters_present_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，说明SPS中是否存在VUI信息。</p><p style="box-sizing: border-box; margin: 10px auto;">2.2 PPS语法元素及其含义</p><p style="box-sizing: border-box; margin: 10px auto;">除了序列参数集SPS之外，H.264中另一重要的参数集合为图像参数集Picture Paramater Set(PPS)。通常情况下，PPS类似于SPS，在H.264的裸码流中单独保存在一个NAL Unit中，只是PPS NAL Unit的nal_unit_type值为8；而在封装格式中，PPS通常与SPS一起，保存在视频文件的文件头中。</p><p style="box-sizing: border-box; margin: 10px auto;">在H.264的协议文档中，PPS的结构定义在7.3.2.2节中，具体的结构如下表所示：</p><p style="text-align:center"><img src="/upload/image/20191022/195047268440.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">其中的每一个语法元素及其含义如下：</p><p style="box-sizing: border-box; margin: 10px auto;">(1) pic_parameter_set_id</p><p style="box-sizing: border-box; margin: 10px auto;">表示当前PPS的id。某个PPS在码流中会被相应的slice引用，slice引用PPS的方式就是在Slice header中保存PPS的id值。该值的取值范围为[0,255]。</p><p style="box-sizing: border-box; margin: 10px auto;">(2) seq_parameter_set_id</p><p style="box-sizing: border-box; margin: 10px auto;">表示当前PPS所引用的激活的SPS的id。通过这种方式，PPS中也可以取到对应SPS中的参数。该值的取值范围为[0,31]。</p><p style="box-sizing: border-box; margin: 10px auto;">(3) entropy_coding_mode_flag</p><p style="box-sizing: border-box; margin: 10px auto;">熵编码模式标识，该标识位表示码流中熵编码/解码选择的算法。对于部分语法元素，在不同的编码配置下，选择的熵编码方式不同。例如在一个宏块语法元素中，宏块类型mb_type的语法元素描述符为“ue(v) | ae(v)”，在baseline profile等设置下采用指数哥伦布编码，在main profile等设置下采用CABAC编码。</p><p style="box-sizing: border-box; margin: 10px auto;">标识位entropy_coding_mode_flag的作用就是控制这种算法选择。当该值为0时，选择左边的算法，通常为指数哥伦布编码或者CAVLC；当该值为1时，选择右边的算法，通常为CABAC。</p><p style="box-sizing: border-box; margin: 10px auto;">(4) bottom_field_pic_order_in_frame_present_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，用于表示另外条带头中的两个语法元素delta_pic_order_cnt_bottom和delta_pic_order_cn是否存在的标识。这两个语法元素表示了某一帧的底场的POC的计算方法。</p><p style="box-sizing: border-box; margin: 10px auto;">(5) num_slice_groups_minus1</p><p style="box-sizing: border-box; margin: 10px auto;">表示某一帧中slice group的个数。当该值为0时，一帧中所有的slice都属于一个slice group。slice group是一帧中宏块的组合方式，定义在协议文档的3.141部分。</p><p style="box-sizing: border-box; margin: 10px auto;">(6) num_ref_idx_l0_default_active_minus1、num_ref_idx_l0_default_active_minus1</p><p style="box-sizing: border-box; margin: 10px auto;">表示当Slice Header中的num_ref_idx_active_override_flag标识位为0时，P/SP/B slice的语法元素num_ref_idx_l0_active_minus1和num_ref_idx_l1_active_minus1的默认值。</p><p style="box-sizing: border-box; margin: 10px auto;">(7) weighted_pred_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，表示在P/SP slice中是否开启加权预测。</p><p style="box-sizing: border-box; margin: 10px auto;">(8) weighted_bipred_idc</p><p style="box-sizing: border-box; margin: 10px auto;">表示在B Slice中加权预测的方法，取值范围为[0,2]。0表示默认加权预测，1表示显式加权预测，2表示隐式加权预测。</p><p style="box-sizing: border-box; margin: 10px auto;">(9) pic_init_qp_minus26和pic_init_qs_minus26</p><p style="box-sizing: border-box; margin: 10px auto;">表示初始的量化参数。实际的量化参数由该参数、slice header中的slice_qp_delta/slice_qs_delta计算得到。</p><p style="box-sizing: border-box; margin: 10px auto;">(10) chroma_qp_index_offset</p><p style="box-sizing: border-box; margin: 10px auto;">用于计算色度分量的量化参数，取值范围为[-12,12]。</p><p style="box-sizing: border-box; margin: 10px auto;">(11) deblocking_filter_control_present_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，用于表示Slice header中是否存在用于去块滤波器控制的信息。当该标志位为1时，slice header中包含去块滤波相应的信息；当该标识位为0时，slice header中没有相应的信息。</p><p style="box-sizing: border-box; margin: 10px auto;">(12) constrained_intra_pred_flag</p><p style="box-sizing: border-box; margin: 10px auto;">若该标识为1，表示I宏块在进行帧内预测时只能使用来自I和SI类型宏块的信息；若该标识位0，表示I宏块可以使用来自Inter类型宏块的信息。</p><p style="box-sizing: border-box; margin: 10px auto;">(13) redundant_pic_cnt_present_flag</p><p style="box-sizing: border-box; margin: 10px auto;">标识位，用于表示Slice header中是否存在redundant_pic_cnt语法元素。当该标志位为1时，slice header中包含redundant_pic_cnt；当该标识位为0时，slice header中没有相应的信息。</p><p style="box-sizing: border-box; margin: 10px auto;">3 解析SDP中包含的H.264的SPS和PPS串</p><p style="box-sizing: border-box; margin: 10px auto;">用RTP传输H264的时候,需要用到sdp协议描述,其中有两项:Sequence Parameter Sets (SPS) 和Picture Parameter Set (PPS)需要用到,那么这两项从哪里获取呢?答案是从H264码流中获取.在H264码流中,都是以&quot;0x00 0x00 0x01&quot;或者&quot;0x00 0x00 0x00 0x01&quot;为开始码的,找到开始码之后,使用开始码之后的第一个字节的低5位判断是否为7(sps)或者8(pps), 及data[4] &amp; 0x1f == 7 || data[4] &amp; 0x1f == 8.然后对获取的nal去掉开始码之后进行base64编码,得到的信息就可以用于sdp.sps和pps需要用逗号分隔开来.</p><p style="box-sizing: border-box; margin: 10px auto;">SDP中的H.264的SPS和PPS串，包含了初始化H.264解码器所需要的信息参数，包括编码所用的profile，level，图像的宽和高，deblock滤波器等。</p><p style="box-sizing: border-box; margin: 10px auto;">由于SDP中的SPS和PPS都是BASE64编码形式的，不容易理解，有一个工具软件可以对SDP中的SPS和PPS进行解析，下载地址：<a class=" external" href="http://link.zhihu.com/?target=http%3A//download.csdn.net/download/davebobo/9898045" rel="nofollow noreferrer" target="_blank" style="box-sizing: border-box; color: rgb(52, 104, 164);"><span class="invisible" style="box-sizing: border-box;">http://<span class="visible" style="box-sizing: border-box;">download.csdn.net/downl<span class="invisible" style="box-sizing: border-box;">oad/davebobo/9898045</span></span></span></a>。</p><p style="box-sizing: border-box; margin: 10px auto;">用法是在命令行中输入：</p><p style="box-sizing: border-box; margin: 10px auto;">spsparser sps.txt pps.txt output.txt</p><p style="box-sizing: border-box; margin: 10px auto;">例如sps.txt中的内容为：</p><p style="box-sizing: border-box; margin: 10px auto;">Z0LgFNoFglE=</p><p style="box-sizing: border-box; margin: 10px auto;">pps.txt中的内容为：</p><p style="box-sizing: border-box; margin: 10px auto;">aM4wpIA=</p><p style="box-sizing: border-box; margin: 10px auto;">最终解析得到的结果为：</p><p style="text-align:center"><img src="/upload/image/20191022/195047590528.png" alt="" style="border: 0px; box-sizing: border-box; max-width: 900px; height: auto;"/></p><p style="box-sizing: border-box; margin: 10px auto;">这里需要特别提一下这两个参数</p><p style="box-sizing: border-box; margin: 10px auto;">pic_width_in_mbs_minus1 = 21</p><p style="box-sizing: border-box; margin: 10px auto;">pic_height_in_mbs_minus1 = 17</p><p style="box-sizing: border-box; margin: 10px auto;">分别表示图像的宽和高，以宏块（16x16）为单位的值减1</p><p style="box-sizing: border-box; margin: 10px auto;">因此，实际的宽为 (21+1)*16 = 352 高为 (17+1)*16 = 288</p><p style="box-sizing: border-box; margin: 10px auto;">到这里应该知道第一部分客户端抓包计算图像宽高遗留下来的问题了吧。</p><p><br/></p>
    </div>
    </div>
</div>
<script type="text/javascript">
// var siteHome = './';
var tutorial_id = 'BB78917A';
var article_id = '2208818C';
</script>

</body>